## 线程常用方法
* 用户线程和守护线程
  > 1. 用户线程：也叫工作线程，当线程的任务执行完成或者通知方式结束
  > 2. 守护线程：一般是为工作线程服务的，当所有的用户线程结束时，守护线程自动结束
  > 3. 常见的守护线程：垃圾回收机制
* 应用案例Thread Method03.java
* 下面我们将测试如何将一个线程设置成守护线程
## 线程的生命周期
* 线程的状态，线程可以处于一下状态之一
> 1. NEW
>   尚未启动的线程处于此状态
> 2. RUNNABLE
>   在Java虚拟机中执行的线程处于此状态
> 3. BLOCKED
>   被阻塞等待监视器锁定的线程处于此状态
> 4. WAITNG
>   正在等待另一个线程执行特定动作的线程处于此状态
> 5. TIMED_WAITING
>   正在等待另一个线程执行动作达到指定等待时间的线程处于此状态
> 6. TERMINATED
>   已退出的线程处于此状态
* 写程序查看线程状态ThreadState_java在state包
## 线程同步机制 synchronized
* 在多线程编程，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在任何时刻，最多有一个线程访问以保证数据的完整性
* 也可以理解：线程同步，即当有一个线程在对内存进行操作时，其他线程都不可以对这个地址进行操作，知道该线程完成操作，其他线程才可以对内核地址进行操作
* SYnchronized具体同步方法
>  1. 同步具体方法-Synchronized
> ```
> synchronized（对象）{//得到对象的锁，才能操作同步代码
>   //需要被同步的代码
>   }
> ```
> 2. synchronized还可以放在方法声明中，表示整个方法为同步方法
> ```
> pulic synchronized void吗（string name）{
>  //需要被同步的代码
> }
> ```
* 使用synchronized解决sy/lxsp里的售票问题
## 互斥锁
* 基本介绍
 > 1.  在Java中，引入了对象互斥锁的概念，来保证共享数据操作的完整性
 > 2. 每个对象都对应于一个可称为“互斥锁”的标记，这个标记用来保证在任一时刻，只
能有一个线程访问该对象。
> 3. 关键字synchronized来与对像的互斥锁联系。当某个对象用synchronized修饰时，
表明该对象在任一时刻只能由一个线访问
> 4. 同步的局限性：导致程序的执行效率要降低
> 5. 同步方法（非静态的）的锁可以是ths,也可以是其他对像（要求是同一个对象）
> 6. 同步方法（静态的）
的锁为当前类本身。
* 注意细节
> 1. 同步方法如果没有使用static修饰，默认锁的对象为this
> 2. 如果方法有static修饰，默认锁的对象：当前类.class
> 3. 实现的步骤：需要分析上锁代码，选择同步代码块或者同步方法，要求多个线程的锁对象为同一个即可
## 线程的死锁
* 基本介绍
 > 多个线程都占用了对方的锁资源，但不肯相让，导致了死锁
* 应用案例DeadLoc.java
## 释放锁
* 下面操作会释放锁
 > 1. 当前线程的同步方法，同步代码块执行结束
 >  ：上完厕所，完事出来
 > 2. 当前线程在同步代码块，同步方法中遇到brea、return
 >  ：没有正常的上完厕所，经理叫他出来修改bug，不得已出来
 > 3. 当前线程在同步代码块，同步方法中出现了未处理的Error或Exception，导致异常结束
 >  ：没有正常上完厕所，发现忘带纸，不得已出来
 > 4. 当前线程在同步代码块，同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁
 >  ：没有正常完事，觉得需要酝酿一下，所以出来等会在进去
 * 下面操作不会释放锁
 > 1. 线程执行同步代码块或同步方法时，程序调用Thread.seep0、Thread.yield（）方
 法暂停当前线程的执行，不会释放锁
 案例：上厕所，太困了，在坑位上眯了一会
 > 2. 线程执行同步代码块时，其他线程调用了该线程的suspend（）方法将该线程挂起，
      该线程不会释放锁。
      提示：应尽量避免使用suspend（）和resume（）来控制线程，方法不再推荐使用
 * 线程练习Homewor01
 > 在main方法中启动两个线程
> 第1个线程循环随机打印100以内的整数
> 直到第2个线程从键盘读取了“Q”命令。